import {
  this.box {axiom-K, axiom-T},
  this.cell {cell, make-cell, mutate},
  this.channel {channel, make-channel, receive, send},
  this.control {discard, grow, loop},
  this.debug {vet},
  this.int {max-int},
  this.magic {cast},
  this.pair {Pair, meta-pair-in},
  this.thread {thread},
  this.unit {Unit, unit},
  this.vector {Vector, for, for-each, meta-vector-in, meta-vector-out, push-back, vector},
}

data _task(a) {
| _Finish
| _Work(work: () -> meta a, result-channel: &channel(a))
}

data future(a) {
| _Future(result-chan: &channel(a))
}

data pool(a: type) {
| _Pool(
    workers: vector(thread(unit)),
    tasks-ref: channel(_task(a)),
    futures-ref: cell(vector(&channel(a))),
  )
}

define _close-pool<a>(k: pool(a)): unit {
  let _Pool of {workers, tasks-ref, futures-ref} = k;
  let size on workers = this.vector.length(workers);
  let _ on tasks-ref =
    loop(size, function (_) {
      send(tasks-ref, box {_Finish})
    });
  for(workers, function (worker, _) {
    attach {worker};
  });
  let futures = axiom-T(this.cell.extract(futures-ref));
  for(futures, function (ch, _) {
    let _ = cast(&channel(a), channel(a), ch);
    Unit
  });
  discard(tasks-ref);
  Unit
}

define _setup-workers<a>(tasks-ref: &channel(_task(a)), size: int): vector(thread(unit)) {
  grow(this.vector.make(8), max-int(size, 1), function (acc, _) {
    push-back(acc, this.thread.detach(
      unit,
      define worker(): unit {
        let v = axiom-T(receive(tasks-ref));
        match v {
        | _Finish =>
          Unit
        | _Work(f, chan) =>
          let result = f();
          send(chan, result);
          worker();
        }
      },
    ))
  })
}

inline with-thread-pool<a, b, e>(size: int, env: e, f: (p: &pool(a), env: meta e) -> meta b): b {
  let tasks-ref = cast(channel(_task(a)), &channel(_task(a)), make-channel());
  let futures-ref = make-cell(box {this.vector.make(8)});
  let workers = _setup-workers(tasks-ref, size);
  let tasks-ref = cast(&channel(_task(a)), channel(_task(a)), tasks-ref);
  let p = _Pool of {workers, tasks-ref, futures-ref};
  let p = cast(pool(a), &pool(a), p);
  let result = f(p, cast(e, meta e, env));
  _close-pool(cast(&pool(a), pool(a), p));
  axiom-T(result)
}

define detach-task<a>(k: &pool(a), f: () -> meta a): future(a) {
  tie _Pool of {tasks-ref, futures-ref} = k;
  let result-chan = cast(channel(a), &channel(a), make-channel());
  mutate(futures-ref, function (futures) {
    box {
      letbox futures = futures;
      letbox result-chan = cast(&channel(a), meta &channel(a), result-chan);
      push-back(futures, result-chan)
    }
  });
  let t = cast(_task(a), meta _task(a), _Work(f, result-chan));
  send(tasks-ref, t);
  _Future(result-chan)
}

define attach-task<a>(i: future(a)): meta a {
  let _Future(result-chan) = i;
  receive(result-chan)
}

inline for-each-parallel<a, b>(worker-num: int, xs: vector(a), f: (a) -> b): vector(b) {
  with-thread-pool(worker-num, Pair(xs, f), function (p, env) {
    let Pair(xs, f) = meta-pair-in(env);
    let fs =
      for-each(meta-vector-in(xs), function (x, _) {
        detach-task(p, function () {
          axiom-K(f, x)
        })
      });
    let xs =
      for-each(fs, function (fut, _) {
        attach-task(fut)
      });
    meta-vector-out(xs)
  })
}

define zen(): unit {
  pin result =
    for-each-parallel(5, Vector[1, 2, 3, 4, 5], function (x) {
      quote {add-int(x, 10)}
    });
  vet(result);
}
