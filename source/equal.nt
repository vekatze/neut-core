import {
  this.binary {binary},
  this.binary.eq {eq-binary},
  this.bool {False, True, bool},
  this.bool.io {print-bool-line},
  this.either {Left, Right},
  this.list {Cons, List, Nil, list},
  this.magic,
  this.memory {load-int, load-pointer},
  this.pair {Pair, pair},
  this.pointer {shift},
  this.rune.eq {eq-rune},
  this.text {text},
  this.type-value {
    Algebraic,
    Binary,
    Constructor,
    Enum,
    Float16,
    Float32,
    Float64,
    Int1,
    Int16,
    Int2,
    Int32,
    Int4,
    Int64,
    Int8,
    Rune,
    Vector,
    Wrapper,
    constructor,
  },
  this.unit {unit},
  this.vector {vector},
  this.word,
}

inline-meta _meta-length<a>(xs: list(a)): int {
  match xs {
  | Nil =>
    0
  | Cons(_, ys) =>
    add-int(1, _meta-length(ys))
  }
}

inline-meta _meta-for-each<a, b>(xs: list(a), !f: (a) -> b): list(b) {
  match xs {
  | Nil =>
    Nil
  | Cons(y, ys) =>
    Cons(f(y), _meta-for-each(ys, f))
  }
}

inline-meta _meta-snd<a, b>(p: pair(a, b)): b {
  let Pair(_, y) = p;
  y
}

inline-meta _join-text(t1: &text, t2: &text): &text {
  let tmp = magic text-uncons(t1);
  match tmp {
  | Left(_) =>
    t2
  | Right(Pair(r, rest)) =>
    magic text-cons(r, _join-text(rest, t2))
  }
}

nominal {
  define-meta eq-data<a>(x: '&a, y: '&a): 'bool,
}

inline-meta _equal-vector<a>(xs: '&vector(a), ys: '&vector(a)): 'bool {
  quote {
    let len-x = this.vector.length(unquote {xs});
    let len-y = this.vector.length(unquote {ys});
    if eq-int(len-x, len-y) {
      this.vector.zip-fold(unquote {xs}, unquote {ys}, True, function (x: &a, y: &a, acc: bool, _: int): bool {
        if acc {
          unquote {eq-data(quote {x}, quote {y})}
        } else {
          False
        }
      })
    } else {
      False
    }
  }
}

inline _load-nth-element(data-arg-num: int, cursor: int, x: pointer): pointer {
  let u = this.word.size;
  let offset = mul-int(u, add-int(1, add-int(data-arg-num, cursor))); // x = (disc, data-args, cons-args)
  let elem-ptr = shift(x, offset);
  load-pointer(elem-ptr)
}

inline-meta _eq-data-adt-cons<a>(
  cons-arg-types: list(type),
  data-arg-num: int,
  cursor: int,
  x: '&a,
  y: '&a,
): 'bool {
  match cons-arg-types {
  | Nil =>
    quote {True}
  | Cons(t, rest) =>
    unpack-type t = t;
    quote {
      let data-arg-num-inner = unquote {promote {data-arg-num}};
      let low-cursor = unquote {promote {cursor}};
      let x-ptr = this.magic.cast<&a, pointer>(unquote {x});
      let y-ptr = this.magic.cast<&a, pointer>(unquote {y});
      let x-elem-ptr = this.magic.cast<pointer, &t>(_load-nth-element(data-arg-num-inner, low-cursor, x-ptr));
      let y-elem-ptr = this.magic.cast<pointer, &t>(_load-nth-element(data-arg-num-inner, low-cursor, y-ptr));
      let is-eq = unquote {eq-data(quote {x-elem-ptr}, quote {y-elem-ptr})};
      if is-eq {
        unquote {_eq-data-adt-cons(rest, data-arg-num, add-int(cursor, 1), x, y)}
      } else {
        False
      }
    }
  }
}

inline-meta _eq-data-adt<a>(
  constructors: list(constructor),
  cons-index: int,
  data-arg-num: int,
  disc: 'int,
  x: '&a,
  y: '&a,
): 'bool {
  match constructors {
  | Nil =>
    quote {True}
  | Cons(Constructor(_, _, xts), rest) =>
    let ts = _meta-for-each(xts, exact _meta-snd);
    quote {
      if eq-int(unquote {promote {cons-index}}, unquote {disc}) {
        unquote {_eq-data-adt-cons(ts, data-arg-num, 0, x, y)}
      } else {
        unquote {_eq-data-adt(rest, add-int(cons-index, 1), data-arg-num, disc, x, y)}
      }
    }
  }
}

define-meta eq-data<a>(x: '&a, y: '&a): 'bool {
  let k = magic inspect-type(a);
  match k {
  | Algebraic(_, data-args, cons-info) =>
    let data-arg-num = _meta-length(data-args);
    quote {
      let ptr-x = this.magic.cast<&a, pointer>(unquote {x});
      let ptr-y = this.magic.cast<&a, pointer>(unquote {y});
      let discriminant-x = load-int(ptr-x);
      let discriminant-y = load-int(ptr-y);
      if ne-int(discriminant-x, discriminant-y) {
        False
      } else {
        unquote {_eq-data-adt(cons-info, 0, data-arg-num, quote {discriminant-x}, x, y)}
      }
    }
  | Enum(_) =>
    quote {
      let discriminant-x = this.magic.cast<&a, int>(unquote {x});
      let discriminant-y = this.magic.cast<&a, int>(unquote {y});
      eq-int(discriminant-x, discriminant-y)
    }
  | Int1 =>
    quote {
      let x = this.magic.cast<&a, int1>(unquote {x});
      let y = this.magic.cast<&a, int1>(unquote {y});
      eq-int1(x, y)
    }
  | Int2 =>
    quote {
      let x = this.magic.cast<&a, int2>(unquote {x});
      let y = this.magic.cast<&a, int2>(unquote {y});
      eq-int2(x, y)
    }
  | Int4 =>
    quote {
      let x = this.magic.cast<&a, int4>(unquote {x});
      let y = this.magic.cast<&a, int4>(unquote {y});
      eq-int4(x, y)
    }
  | Int8 =>
    quote {
      let x = this.magic.cast<&a, int8>(unquote {x});
      let y = this.magic.cast<&a, int8>(unquote {y});
      eq-int8(x, y)
    }
  | Int16 =>
    quote {
      let x = this.magic.cast<&a, int16>(unquote {x});
      let y = this.magic.cast<&a, int16>(unquote {y});
      eq-int16(x, y)
    }
  | Int32 =>
    quote {
      let x = this.magic.cast<&a, int32>(unquote {x});
      let y = this.magic.cast<&a, int32>(unquote {y});
      eq-int32(x, y)
    }
  | Int64 =>
    quote {
      let x = this.magic.cast<&a, int64>(unquote {x});
      let y = this.magic.cast<&a, int64>(unquote {y});
      eq-int64(x, y)
    }
  | Float16 =>
    quote {
      let x = this.magic.cast<&a, float16>(unquote {x});
      let y = this.magic.cast<&a, float16>(unquote {y});
      eq-float16(x, y)
    }
  | Float32 =>
    quote {
      let x = this.magic.cast<&a, float32>(unquote {x});
      let y = this.magic.cast<&a, float32>(unquote {y});
      eq-float32(x, y)
    }
  | Float64 =>
    quote {
      let x = this.magic.cast<&a, float64>(unquote {x});
      let y = this.magic.cast<&a, float64>(unquote {y});
      eq-float64(x, y)
    }
  | Rune =>
    quote {
      let x = this.magic.cast<&a, rune>(unquote {x});
      let y = this.magic.cast<&a, rune>(unquote {y});
      eq-rune(x, y)
    }
  | Binary =>
    quote {
      let x = this.magic.cast<&a, &binary>(unquote {x});
      let y = this.magic.cast<&a, &binary>(unquote {y});
      eq-binary(x, y)
    }
  | Vector(t) =>
    unpack-type t = t;
    quote {
      let x: &vector(t) = this.magic.cast<&a, &vector(t)>(unquote {x});
      let y: &vector(t) = this.magic.cast<&a, &vector(t)>(unquote {y});
      unquote {_equal-vector<t>(quote {x}, quote {y})}
    }
  | Wrapper(t) =>
    unpack-type t = t;
    quote {
      let x: &t = this.magic.cast<&a, &t>(unquote {x});
      let y: &t = this.magic.cast<&a, &t>(unquote {y});
      unquote {eq-data(quote {x}, quote {y})}
    }
  | _ =>
    let t = magic show-type(a);
    let message = _join-text("eq-data doesn't support: ", t);
    magic compile-error(message)
  }
}

define zen(): unit {
  pin xs: vector(list(int)) = this.vector.Vector[List[], List[10, 20]];
  pin ys: vector(list(int)) = this.vector.Vector[List[], List[10, 20]];
  let foo = eq-data::(xs, ys);
  // pin f: list((int) -> int) =
  //   List[function (x) {
  //     x
  //   }];
  // pin g: list((int) -> int) =
  //   List[function (x) {
  //     x
  //   }];
  // let foo = unquote {eq-data(quote {f}, quote {g})};
  print-bool-line(foo);
}
