import {
  this.box {axiom-T},
  this.c-size {C-Size, from-c-size},
  this.external {
    free,
    malloc,
    thread-mutex-destroy,
    thread-mutex-init,
    thread-mutex-lock,
    thread-mutex-unlock,
  },
  this.foreign {THREAD_MUTEX_SIZE},
  this.int {sum-int},
  this.list {List},
  this.magic {cast},
  this.memory {load-int, store-int},
  this.pair {Pair, pair},
  this.pointer {shift},
  this.type-tag {Opaque, type-tag-to-int},
  this.unit {Unit, unit},
  this.word,
}

inline _get-clone<a>(x: &a): a {
  *x
}

nominal {
  alias _cell,
}

data cell(_: type) {
| _Cell(_cell)
}

define _new<a>(val: a): cell(a) {
  let mutex-size = from-c-size(THREAD_MUTEX_SIZE);
  let u = this.word.size;
  let ptr = malloc(C-Size(sum-int(List[u, mutex-size, u])));
  store-int(cast<a, int>(val), ptr);
  let _ = thread-mutex-init(shift(ptr, u));
  store-int(cast<type, int>(magic term-type(a)), shift(ptr, add-int(u, mutex-size)));
  cast<pointer, cell(a)>(ptr)
}

// (content, thread-mutex, type)
resource _cell {
  function (ch: pointer) {
    let u = this.word.size;
    let mutex-size = from-c-size(THREAD_MUTEX_SIZE);
    let type-offset = add-int(u, mutex-size);
    let a = cast<int, type>(load-int(shift(ch, type-offset)));
    thread-mutex-destroy(shift(ch, u));
    magic call-type(a, 0, load-int(ch));
    free(ch)
  },
  function (ch: pointer) {
    let u = this.word.size;
    let mutex-size = from-c-size(THREAD_MUTEX_SIZE);
    let type-offset = add-int(u, mutex-size);
    let a = cast<int, type>(load-int(shift(ch, type-offset)));
    let val-clone = magic call-type(a, 1, load-int(ch));
    _new(a, val-clone) // これができないと、newでval-cloneの型情報を埋め込めない？
  },
  type-tag-to-int(Opaque),
}

inline make-cell<a>(initial-value: meta a): cell(a) {
  _new<a>(axiom-T(initial-value))
}

inline modify<a, b>(ch: &cell(a), f: (meta a) -> pair(meta a, b)): b {
  let ch = cast<&cell(a), pointer>(ch);
  let u = this.word.size;
  let mutex-ptr = shift(ch, u);
  thread-mutex-lock(mutex-ptr);
  let val-base: int = load-int(ch);
  let orig-val = cast<int, meta a>(val-base);
  let Pair(new-val, result) = f(orig-val);
  store-int(cast<meta a, int>(new-val), ch);
  thread-mutex-unlock(mutex-ptr);
  result
}

inline mutate<a>(ch: &cell(a), f: (meta a) -> meta a): unit {
  modify(ch, function (x) {
    Pair(f(x), Unit)
  })
}

inline borrow<a, b>(ch: &cell(a), f: (&a) -> meta b): b {
  let ch = cast<&cell(a), pointer>(ch);
  let u = this.word.size;
  let mutex-ptr = shift(ch, u);
  thread-mutex-lock(mutex-ptr);
  let val-base: int = load-int(ch);
  let val: &a = cast<int, &a>(val-base);
  letbox-T result = f(val);
  thread-mutex-unlock(mutex-ptr);
  result
}

define clone<a>(ch: &cell(a)): a {
  borrow(ch, function (val: &a) {
    box val {val}
  })
}

define extract<a>(c: cell(a)): meta a {
  let u = this.word.size;
  let ch = cast<cell(a), pointer>(c);
  let result = cast<int, meta a>(load-int(ch));
  thread-mutex-destroy(shift(ch, u));
  this.external.free(ch);
  result
}
