import {
  this.bool {False, True, bool},
  this.box,
  this.float.show,
  this.int.show,
  this.text {text},
  this.text.io {print-line},
  this.unit {unit},
}

data chunk {
| Chunk-Text(content: text)
| Chunk-Text-N(content: &text)
| Chunk-Int(content: int)
| Chunk-Float(content: float, digits: int)
| Chunk-Rune(content: rune)
| Chunk-Style(content: &text)
}

data doc {
| Nil
| Chunk(content: chunk, cont: doc)
| Line(indentation: int, cont: doc)
| Group(content: doc)
}

define append(d1: doc, d2: doc): doc {
  match d1 {
  | Nil =>
    d2
  | Chunk(c, cont) =>
    Chunk(c, append(cont, d2))
  | Line(i, cont) =>
    Line(i, append(cont, d2))
  | Group(d1') =>
    Group(append(d1', d2))
  }
}

rule-right join {
  function leaf(_: int): doc {
    Nil
  },
  function node-left(d: doc, acc: doc): doc {
    append(d, acc)
  },
  function root<a>(x: a): a {
    x
  },
}

define layout(d: doc): text {
  match d {
  | Nil =>
    *""
  | Chunk(c, cont) =>
    match c {
    | Chunk-Text(t) =>
      pin t = t;
      pin cont = layout(cont);
      this.text.append(t, cont)
    | Chunk-Text-N(t) =>
      pin cont = layout(cont);
      this.text.append(t, cont)
    | Chunk-Int(x) =>
      pin t = this.int.show.show-int(x);
      pin cont = layout(cont);
      this.text.append(t, cont)
    | Chunk-Float(x, digits) =>
      pin t = this.float.show.show-float(x, digits);
      pin cont = layout(cont);
      this.text.append(t, cont)
    | Chunk-Rune(x) =>
      pin t = this.text.singleton(x);
      pin cont = layout(cont);
      this.text.append(t, cont)
    | Chunk-Style(t) =>
      pin cont = layout(cont);
      this.text.append(t, cont)
    }
  | Line(i, cont) =>
    pin tmp = this.text.replicate(" ", i);
    pin cont = layout(cont);
    pin foo = this.text.append(tmp, cont);
    this.text.append("\n", foo)
  | Group(d) =>
    *"tmp"
  }
}

define nest(i: int, d: doc): doc {
  match d {
  | Nil =>
    Nil
  | Chunk(c, cont) =>
    Chunk(c, nest(i, cont))
  | Line(j, cont) =>
    Line(add-int(i, j), nest(i, cont))
  | Group(d) =>
    Group(nest(i, d))
  }
}

inline atom(t: text): doc {
  Chunk(Chunk-Text(t), Nil)
}

inline atom-N(t: &text): doc {
  Chunk(Chunk-Text-N(t), Nil)
}

inline atom-int(x: int): doc {
  Chunk(Chunk-Int(x), Nil)
}

inline atom-float(x: float, digits: int): doc {
  Chunk(Chunk-Float(x, digits), Nil)
}

inline atom-rune(x: rune): doc {
  Chunk(Chunk-Rune(x), Nil)
}

inline newline: doc {
  Line(0, Nil)
}

define ansi-reset: doc {
  atom-N("\u{1b}[0m")
}

define ansi-bold: doc {
  atom-N("\u{1b}[1m")
}

define ansi-blue: doc {
  atom-N("\u{1b}[34m")
}

define nested(prefix: doc, body: doc, suffix: doc): doc {
  join[
    prefix,
    nest(
      2,
      append(newline, body),
    ),
    newline,
    suffix,
  ]
}

define append-vertical(d1: doc, d2: doc): doc {
  join[d1, newline, d2]
}

define in-paren(d: doc): doc {
  nested(
    atom(*"("),
    d,
    atom(*")"),
  )
}

data _arg {
| _Arg(
    size: int,
    index: int,
    item: doc,
  )
}

rule-right arguments {
  function leaf(size: int): _arg {
    _Arg(size, sub-int(size, 1), Nil)
  },
  function node-right(d: doc, acc: _arg): _arg {
    let _Arg(size, index, acc) = acc;
    if eq-int(size, add-int(index, 1)) {
      _Arg(size, sub-int(index, 1), append(d, acc))
    } else {
      _Arg(size, sub-int(index, 1), append-vertical(d, acc))
    }
  },
  function root(x: _arg): doc {
    let _Arg(_, _, x) = x;
    in-paren(x)
  },
}

define zen(): unit {
  pin tmp =
    layout(
      join[
        atom(*"Cons"),
        in-paren(
          join[
            ansi-bold,
            ansi-blue,
            atom(*"Cons"),
            ansi-reset,
            arguments[
              atom(*"my-item,"),
              atom(*"sample,"),
              atom(*"yo,"),
            ],
          ],
        ),
      ],
    );
  print-line(tmp)
}
