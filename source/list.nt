import {
  Ord {Ord, ord},
  this.bool {False, True, and, bool, or},
  this.box,
  this.either {Left, Right, either, none},
  this.monoid {Monoid, monoid},
  this.ordering {GT, LT},
  this.pair {Pair, pair},
  this.unit {Unit, unit},
}

data list(a: type) {
| Nil
| Cons(a, list(a))
}

// folds are optimized into loops
inline fold-left<elem-type, result-type>(
  acc: result-type,
  xs: list(elem-type),
  !consumer: (result-type, elem-type) -> result-type,
): result-type {
  let helper =
    define loop(acc, xs): result-type {
      match xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        loop(!consumer(acc, y), ys)
      }
    }
  in
  helper(acc, xs)
}

inline fold-left-N<elem-type, result-type>(
  acc: result-type,
  xs: &list(elem-type),
  !consumer: (result-type, &elem-type) -> result-type,
): result-type {
  let helper =
    define loop(acc, xs): result-type {
      case xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        loop(!consumer(acc, y), ys)
      }
    }
  in
  helper(acc, xs)
}

inline fold-left-with-index<elem-type, result-type>(
  acc: result-type,
  xs: list(elem-type),
  !consumer: (result-type, elem-type, int) -> result-type,
): result-type {
  let helper =
    define loop(acc, xs, i): result-type {
      match xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        loop(!consumer(acc, y, i), ys, add-int(i, 1))
      }
    }
  in
  helper(acc, xs, 0)
}

inline fold-right<elem-type, result-type>(
  xs: list(elem-type),
  acc: result-type,
  !consumer: (elem-type, result-type) -> result-type,
): result-type {
  let helper =
    define loop(xs, acc): result-type {
      match xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        !consumer(y, loop(ys, acc))
      }
    }
  in
  helper(xs, acc)
}

inline fold-right-N<elem-type, result-type>(
  xs: &list(elem-type),
  acc: result-type,
  !consumer: (&elem-type, result-type) -> result-type,
): result-type {
  let helper =
    define loop(xs, acc): result-type {
      case xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        !consumer(y, loop(ys, acc))
      }
    }
  in
  helper(xs, acc)
}

define intercalate<a>(xs: list(a), !sep: a): list(a) {
  match xs {
  | Nil =>
    []
  | Cons(y, Nil) =>
    [y]
  | Cons(y, Cons(z, ys)) =>
    Cons(y, Cons(!sep, intercalate(Cons(z, ys), !sep)))
  }
}

// [x1, x2, x3], [y1, y2, y3]
// => [x1, y1, x2, y2, x3, y3]
define alternate<a>(xs: list(a), ys: list(a)): list(a) {
  match xs, ys {
  | Nil, Nil =>
    Nil
  | xs, Nil =>
    xs
  | Nil, ys =>
    ys
  | Cons(x', xs'), Cons(y', ys') =>
    Cons(x', Cons(y', alternate(xs', ys')))
  }
}

inline for-each<a, b>(xs: list(a), !f: (a) -> b): list(b) {
  let helper =
    define loop(xs: list(a), acc: list(b)): list(b) {
      match xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        Cons(!f(y), loop(ys, acc))
      }
    }
  in
  helper(xs, [])
}

inline for-each-N<a, b>(xs: &list(a), !f: (&a) -> b): list(b) {
  let helper =
    define loop(xs: &list(a), acc: list(b)): list(b) {
      case xs {
      | Nil =>
        acc
      | Cons(y, ys) =>
        Cons(!f(y), loop(ys, acc))
      }
    }
  in
  helper(xs, [])
}

inline try-for-each<a, e, b>(xs: list(a), !f: (a) -> either(e, b)): either(e, list(b)) {
  let f =
    define self(xs: list(a)): either(e, list(b)) {
      match xs {
      | Nil =>
        Right(Nil)
      | Cons(y, ys) =>
        try z = !f(y) in
        try zs = self(ys) in
        Right(Cons(z, zs))
      }
    }
  in
  f(xs)
}

inline try-for-each-N<a, e, b>(xs: &list(a), !f: (&a) -> either(e, b)): either(e, list(b)) {
  let f =
    define self(xs: &list(a)): either(e, list(b)) {
      case xs {
      | Nil =>
        Right(Nil)
      | Cons(y, ys) =>
        try z = !f(y) in
        try zs = self(ys) in
        Right(Cons(z, zs))
      }
    }
  in
  f(xs)
}

inline for<a>(xs: list(a), f: (a) -> unit): unit {
  let _ = for-each(xs, f) in
  Unit
}

inline for-N<a>(xs: &list(a), f: (&a) -> unit): unit {
  let _ = for-each-N(xs, f) in
  Unit
}

define append<a>(xs: list(a), ys: list(a)): list(a) {
  fold-right(xs, ys, exact Cons)
}

define concat<a>(xss: list(list(a))): list(a) {
  fold-left([], xss, exact append)
}

define reverse<a>(xs: list(a)): list(a) {
  fold-left([], xs, function (acc, x) {
    Cons(x, acc)
  })
}

inline iterate<a>(count: int, !f: (int) -> a): list(a) {
  let helper =
    define self(cursor): list(a) {
      if ge-int(cursor, count) {
        Nil
      } else {
        Cons(!f(cursor), self(add-int(cursor, 1)))
      }
    }
  in
  helper(0)
}

inline try-iterate<e, a>(count: int, !f: (int) -> either(e, a)): either(e, list(a)) {
  let helper =
    define self(acc: list(a), cursor: int): either(e, list(a)) {
      match ge-int(cursor, count) {
      | True =>
        Right(reverse(acc))
      | False =>
        try v = !f(cursor) in
        self(Cons(v, acc), add-int(cursor, 1))
      }
    }
  in
  helper([], 0)
}

define length<a>(xs: &list(a)): int {
  fold-left-N(0, xs, function (acc, _) {
    add-int(1, acc)
  })
}

inline zip-with<a, b, c>(xs: list(a), ys: list(b), !f: (a, b) -> c): list(c) {
  let k =
    define loop(xs: list(a), ys: list(b)): list(c) {
      match xs, ys {
      | Nil, _ =>
        Nil
      | _, Nil =>
        Nil
      | Cons(x, xs'), Cons(y, ys') =>
        Cons(!f(x, y), loop(xs', ys'))
      }
    }
  in
  k(xs, ys)
}

inline zip-with-N<a, b, c>(xs: &list(a), ys: &list(b), !f: (&a, &b) -> c): list(c) {
  let k =
    define loop(xs: &list(a), ys: &list(b)): list(c) {
      case xs, ys {
      | Nil, _ =>
        Nil
      | _, Nil =>
        Nil
      | Cons(x, xs'), Cons(y, ys') =>
        Cons(!f(x, y), loop(xs', ys'))
      }
    }
  in
  k(xs, ys)
}

define zip<a, b>(xs: list(a), ys: list(b)): list(pair(a, b)) {
  zip-with(xs, ys, exact Pair)
}

define zip-N<a, b>(xs: &list(a), ys: &list(b)): list(pair(&a, &b)) {
  zip-with-N(xs, ys, function (x, y) {
    Pair(x, y)
  })
}

define unzip<a, b>(xs: list(pair(a, b))): pair(list(a), list(b)) {
  fold-right(xs, Pair([], []), function (x, acc) {
    let Pair(l, r) = x in
    let Pair(rest-l, rest-r) = acc in
    Pair(Cons(l, rest-l), Cons(r, rest-r))
  })
}

define uncons<a>(xs: list(a)): ?pair(a, list(a)) {
  match xs {
  | Nil =>
    none()
  | Cons(y, ys) =>
    Right(Pair(y, ys))
  }
}

define unsnoc<a>(xs: list(a)): ?pair(list(a), a) {
  let f =
    define _unsnoc(xs: list(a), acc: list(a)): ?pair(list(a), a) {
      match xs {
      | Nil =>
        Left(Unit)
      | Cons(y, Nil) =>
        Right(Pair(reverse(acc), y))
      | Cons(y, ys) =>
        _unsnoc(ys, Cons(y, acc))
      }
    }
  in
  f(xs, [])
}

define all(xs: list(bool)): bool {
  fold-left(True, xs, and)
}

define any(xs: list(bool)): bool {
  fold-left(False, xs, or)
}

// right-open interval
define range(from: int, to: int): list(int) {
  if eq-int(from, to) {
    Nil
  } else {
    Cons(from, range(add-int(from, 1), to))
  }
}

inline find<a>(xs: &list(a), !pred: (&a) -> bool): ?&a {
  let f =
    define self(ys: &list(a)): ?&a {
      case ys {
      | Nil =>
        none()
      | Cons(z, zs) =>
        if !pred(z) {
          Right(z)
        } else {
          self(zs)
        }
      }
    }
  in
  f(xs)
}

inline filter<a>(xs: list(a), !pred: (&a) -> bool): list(a) {
  let f =
    define self(xs: list(a)): list(a) {
      match xs {
      | Nil =>
        Nil
      | Cons(y, ys) =>
        let b on y = !pred(y) in
        if b {
          Cons(y, self(ys))
        } else {
          self(ys)
        }
      }
    }
  in
  f(xs)
}

define filter-some<a>(xs: list(?a)): list(a) {
  fold-right(xs, [], function (x, acc) {
    match x {
    | Right(v) =>
      Cons(v, acc)
    | Left(_) =>
      acc
    }
  })
}

inline sum<a>(as-monoid: monoid(a), xs: list(a)): a {
  let Monoid of {e, op} = as-monoid in
  fold-left(e, xs, function (acc, x) {
    op(acc, x)
  })
}

inline minimum<a>(as-ord: ord(&a)): (list(a)) -> ?a {
  function (xs) {
    let Ord of {compare} = as-ord in
    match xs {
    | Nil =>
      none()
    | Cons(y, ys) =>
      Right(fold-left(y, ys, function (acc, y) {
        let order on acc, y = compare(acc, y) in
        match order {
        | LT =>
          acc
        | _ =>
          y
        }
      }))
    }
  }
}

inline maximum<a>(as-ord: ord(&a)): (list(a)) -> ?a {
  function (xs) {
    let Ord of {compare = !compare} = as-ord in
    let helper =
      define self(cand: a, ys: list(a)): a {
        match ys {
        | Nil =>
          cand
        | Cons(z, zs) =>
          let order on cand, z = !compare(cand, z) in
          match order {
          | GT =>
            self(cand, zs)
          | _ =>
            self(z, zs)
          }
        }
      }
    in
    match xs {
    | Nil =>
      none()
    | Cons(y, ys) =>
      Right(helper(y, ys))
    }
  }
}

define take<a>(xs: list(a), n: int): list(a) {
  if le-int(n, 0) {
    []
  } else {
    match xs {
    | Nil =>
      Nil
    | Cons(y, ys) =>
      Cons(y, take(ys, sub-int(n, 1)))
    }
  }
}

define take-N<a>(xs: &list(a), n: int): list(a) {
  if le-int(n, 0) {
    []
  } else {
    case xs {
    | Nil =>
      Nil
    | Cons(y, ys) =>
      Cons(*y, take-N(ys, sub-int(n, 1)))
    }
  }
}

define drop<a>(xs: list(a), n: int): list(a) {
  if le-int(n, 0) {
    xs
  } else {
    match xs {
    | Nil =>
      Nil
    | Cons(_, ys) =>
      drop(ys, sub-int(n, 1))
    }
  }
}

define drop-N<a>(xs: &list(a), n: int): list(a) {
  if le-int(n, 0) {
    *xs
  } else {
    case xs {
    | Nil =>
      Nil
    | Cons(_, ys) =>
      drop-N(ys, sub-int(n, 1))
    }
  }
}

define _split<a>(xs: list(a), n: int, head-acc: list(a)): pair(list(a), list(a)) {
  if le-int(n, 0) {
    Pair(reverse(head-acc), xs)
  } else {
    match xs {
    | Nil =>
      Pair(head-acc, Nil)
    | Cons(y, ys) =>
      _split(ys, sub-int(n, 1), Cons(y, head-acc))
    }
  }
}

define _split-N<a>(xs: &list(a), n: int, head-acc: list(a)): pair(list(a), list(a)) {
  if le-int(n, 0) {
    Pair(reverse(head-acc), *xs)
  } else {
    case xs {
    | Nil =>
      Pair(head-acc, Nil)
    | Cons(y, ys) =>
      _split-N(ys, sub-int(n, 1), Cons(*y, head-acc))
    }
  }
}

define split<a>(xs: list(a), n: int): pair(list(a), list(a)) {
  _split(xs, n, [])
}

define split-N<a>(xs: &list(a), n: int): pair(list(a), list(a)) {
  _split-N(xs, n, [])
}

define product<a, b>(xs: list(a), ys: list(b)): list(pair(a, b)) {
  let xyss =
    for-each(xs, function (x) {
      for-each(ys, function (y) {
        Pair(x, y)
      })
    })
  in
  concat(xyss)
}

define is-empty<a>(xs: &list(a)): bool {
  case xs {
  | Nil =>
    True
  | _ =>
    False
  }
}

define nth<a>(xs: &list(a), n: int): ?a {
  case xs {
  | Nil =>
    none()
  | Cons(y, ys) =>
    if le-int(n, 0) {
      Right(*y)
    } else {
      nth(ys, sub-int(n, 1))
    }
  }
}

inline span<a>(xs: list(a), !pred: (&a) -> bool): pair(list(a), list(a)) {
  let f =
    define self(xs: list(a)): pair(list(a), list(a)) {
      match xs {
      | [] =>
        Pair([], [])
      | Cons(y, ys) =>
        let cond on y = !pred(y) in
        if cond {
          let Pair(former, latter) = self(ys) in
          Pair(Cons(y, former), latter)
        } else {
          Pair([], Cons(y, ys))
        }
      }
    }
  in
  f(xs)
}

inline span-N<a>(xs: &list(a), !pred: (&a) -> bool): pair(list(a), list(a)) {
  let f =
    define self(xs: &list(a)): pair(list(a), list(a)) {
      case xs {
      | [] =>
        Pair([], [])
      | Cons(y, ys) =>
        if !pred(y) {
          let Pair(former, latter) = self(ys) in
          Pair(Cons(*y, former), latter)
        } else {
          Pair([], Cons(*y, *ys))
        }
      }
    }
  in
  f(xs)
}

inline take-while<a>(xs: list(a), !pred: (&a) -> bool): list(a) {
  let f =
    define self(xs: list(a)): list(a) {
      match xs {
      | [] =>
        []
      | Cons(y, ys) =>
        let cond on y = !pred(y) in
        if cond {
          Cons(y, self(ys))
        } else {
          []
        }
      }
    }
  in
  f(xs)
}

inline take-while-N<a>(xs: &list(a), !pred: (&a) -> bool): list(a) {
  let f =
    define self(xs: &list(a)): list(a) {
      case xs {
      | [] =>
        []
      | Cons(y, ys) =>
        if !pred(y) {
          Cons(*y, self(ys))
        } else {
          []
        }
      }
    }
  in
  f(xs)
}

inline drop-while<a>(xs: list(a), !pred: (&a) -> bool): list(a) {
  let f =
    define self(xs: list(a)): list(a) {
      match xs {
      | [] =>
        []
      | Cons(y, ys) =>
        let cond on y = !pred(y) in
        if cond {
          self(ys)
        } else {
          Cons(y, ys)
        }
      }
    }
  in
  f(xs)
}

inline drop-while-N<a>(xs: &list(a), !pred: (&a) -> bool): list(a) {
  let f =
    define self(xs: &list(a)): list(a) {
      case xs {
      | [] =>
        []
      | Cons(y, ys) =>
        if !pred(y) {
          self(ys)
        } else {
          Cons(*y, *ys)
        }
      }
    }
  in
  f(xs)
}
